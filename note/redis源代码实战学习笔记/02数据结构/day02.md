# 字符串

1. 实现字符串时满足三个要求
    * 能支持丰富且高效的字符串操作，比如字符串追加、拷贝、比较、获取长度
    * 能保存任意的二进制数据，比如图片
    * 能尽可能低节省内存开销
2. 为什么不用C语言的字符串**Char***
    * 使用C的字符串时，经常需要手动检查和分配字符串空间，从而增加代码开发工作量
    * 图片无法用字符串保存，应用受限
3. 相比于C,Redis设计了简单动态字符串SDS(Simple Dynamic String)
    1. 提升字符串的操作效率
    2. 可以保存二进制数据
4. char*的结构设计
    * char*字符数组的结构很简单，就是一块连续的内存空间，依次存放了字符串中的每一个字符
    * char*指针指向字符数组的起始位置，而字符数组的结尾位置就用"\0"表示，意思是指字符串的结束
    * "\0"结束字符对字符串长度的影响，如果保存数据中本身有"\0"那么数据在"\0"处就被截断，不符合redis希望保存任意二进制数据的需求
5. 操作函数复杂度
    * strlen函数获取字符串的长度，操作函数复杂度为O(n)
    * 字符串追加函数strcat(将一个源字符串src追加到一个目标字符串的末尾)
        * 先遍历字符串才能得到目标字符串的末尾
        * 先遍历源字符串才能追加
        * 需要确认目标字符串具有足够的空间
        * 不符合redis对字符串高效操作的需求
6. SDS的设计思想
    * SDS结构设计
        * 保存实际数据：字符数组buff[]
        * 字符串现有长度：len
        * 分配给字符数组的空间长度alloc
        * SDS类型flags
        * 定义 ```typedef char *sds```SDS本质还是字符数组，只是在字符数组的基础上增加了额外的元数据。在Redis中需要用到字符数组时，就直接使用sds这个别名
        * 创建新的字符串时[sdsnewlen](../../../src/sds.c)
          * 调用SDS创建函数 sdsnewlen
          * sdsnewlen函数会新建sds类型的变量，并新建sds结构体，把sds结构体中的数组buff赋给sds类型变量
          * sdsnewleng函数会把要创建的字符串拷贝给sds变量
    * SDS操作效率
      * 因为SDS结构中记录了字符数组中已经占用的空间和被分配的空间，就比传统C语言实现的字符串带来更高的操作效率
      * 以字符串追加为例子[sdscatlen](../../../src/sds.c)
        * 参数：目标字符串s,源字符串t,要追加的长度len
    * 紧凑型字符串结构的变成技巧
      * 元数据flags表示SDS的类型,事实上SDS一共设计了5种类型，分别是sdshdr5（不再使用）、sdshdr8、sdshdr16、sdshdr32和sdshdr64,区别在于：数据结构中的字符数组现有长度len和分配空间长度alloc,这两个元数据的数据类型不同
      ```c
        struct __atribute__ ((__packed__)) sdshdr8{
            uint8_t len;/*字符数组的现有长度*/
            uint8_t alloc;/*字符数组的已分配空间，不包括结构体和\0结束字符*/
            unsigned char flags;/*SDS类型*/
            char buff[];/*字符数组*/
        };
      ```
      * SDS之所以设计不同的结构头（即不同类型），是为了能灵活保存不同大小的字符串，从而有效节省内存空间。
      * 在编程上还使用了专门的编译优化来节省内存空间。 ***struct __attribute__ ((__packed__)) sdshdr8***的作用告诉编译器，不要使用内存对齐的方式，而是采用紧凑的方式分配内存
      

    
 